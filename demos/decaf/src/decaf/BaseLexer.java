package decaf;

import java.io.IOException;

import decaf.Driver;
import decaf.Location;
import decaf.error.*;
import decaf.Tree;

/**
 * Base class of `Lexer`, which is generated by `JFlex`.
 */
public abstract class BaseLexer {

    private Parser parser;

    public void setParser(Parser parser) {
        this.parser = parser;
    }

    /**
     * Lexer function of `JFlex`.
     *
     * @return the parsed token from input.
     * @throws IOException
     */
    abstract int yylex() throws IOException;

    abstract Location getLocation();

    private DecafError error = null;

    public void handleError() throws DecafError {
        if (error != null) throw error;
    }

    protected void issueError(DecafError err) {
        error = err;
    }

    protected void setSemantic(Location where, SemValue v) {
        v.loc = where;
        parser.val = v;
    }

    protected int keyword(int code) {
        setSemantic(getLocation(), SemValue.createKeyword(code));
        return code;
    }

    protected int operator(int code) {
        setSemantic(getLocation(), SemValue.createOperator(code));
        return code;
    }

    protected int boolConst(boolean bval) {
        setSemantic(getLocation(), SemValue.createLiteral(Tree.BOOL, bval));
        return Parser.LITERAL;
    }

    protected int StringConst(String sval, Location loc) {
        setSemantic(loc, SemValue.createLiteral(Tree.STRING, sval));
        return Parser.LITERAL;
    }

    protected int intConst(String ival) {
        try {
            setSemantic(getLocation(), SemValue.createLiteral(
                    Tree.INT, Integer.decode(ival)));
        } catch (NumberFormatException e) {
            issueError(new IntTooLargeError(getLocation(), ival));
        }
        return Parser.LITERAL;
    }

    protected int identifier(String name) {
        setSemantic(getLocation(), SemValue.createIdentifier(name));
        return Parser.IDENTIFIER;
    }

    public void diagnose() throws IOException {
        while (yylex() != 0) {
            System.out.println(parser.lookahead);
        }
    }

}
