%package decaf
%import
decaf.Location
decaf.Tree
decaf.Tree.*
java.util.*

%class Parser extends BaseParser
%sem SemValue
%start Expr

%tokens
VOID   BOOL  INT   STRING   CLASS
NULL   EXTENDS     THIS     WHILE   FOR
IF     ELSE        RETURN   BREAK   NEW
SWITCH CASE        DEFAULT  REPEAT  UNTIL    // new keywords for switch-case and repeat-until
PRINT  READ_INTEGER         READ_LINE
LITERAL
IDENTIFIER	AND    OR    STATIC  INSTANCEOF
SELF_PLUS    SELF_MINUS                      // add: ++, --
LESS_EQUAL   GREATER_EQUAL  EQUAL   NOT_EQUAL
'+'  '-'  '*'  '/'  '%'  '='  '>'  '<'  '.'
','  ';'  '!'  '('  ')'  '['  ']'  '{'  '}'
'?'  ':'

%%

// operators
Oper2           :   OR
                    {
                        $$.signal = Tree.OR;
                        $$.loc = $1.loc;
                    }
                ;

Oper3           :   AND
                    {
                        $$.signal = Tree.AND;
                        $$.loc = $1.loc;
                    }
                ;

Oper4           :   EQUAL
                    {
                        $$.signal = Tree.EQ;
                        $$.loc = $1.loc;
                    }
                |   NOT_EQUAL
                    {
                        $$.signal = Tree.NE;
                        $$.loc = $1.loc;
                    }
                ;

Oper5           :   LESS_EQUAL
                    {
                        $$.signal = Tree.LE;
                        $$.loc = $1.loc;
                    }
                |   GREATER_EQUAL
                    {
                        $$.signal = Tree.GE;
                        $$.loc = $1.loc;
                    }
                |   '<'
                    {
                        $$.signal = Tree.LT;
                        $$.loc = $1.loc;
                    }
                |   '>'
                    {
                        $$.signal = Tree.GT;
                        $$.loc = $1.loc;
                    }
                ;

Oper6           :   '+'
                    {
                        $$.signal = Tree.PLUS;
                        $$.loc = $1.loc;
                    }
                |   '-'
                    {
                        $$.signal = Tree.MINUS;
                        $$.loc = $1.loc;
                    }
                ;

Oper7           :   '*'
                    {
                        $$.signal = Tree.MUL;
                        $$.loc = $1.loc;
                    }
                |   '/'
                    {
                        $$.signal = Tree.DIV;
                        $$.loc = $1.loc;
                    }
                |   '%'
                    {
                        $$.signal = Tree.MOD;
                        $$.loc = $1.loc;
                    }
                ;

Oper8           :   '-'
                    {
                        $$.signal = Tree.NEG;
                        $$.loc = $1.loc;
                    }
                |   '!'
                    {
                        $$.signal = Tree.NOT;
                        $$.loc = $1.loc;
                    }
                ;

Oper9           :   SELF_PLUS
                    {
                        $$.signal = Tree.PREINC;
                        $$.loc = $1.loc;
                    }
                |   SELF_MINUS
                    {
                        $$.signal = Tree.PREDEC;
                        $$.loc = $1.loc;
                    }
                ;

Oper10          :   SELF_PLUS
                    {
                        $$.signal = Tree.POSTINC;
                        $$.loc = $1.loc;
                    }
                |   SELF_MINUS
                    {
                        $$.signal = Tree.POSTDEC;
                        $$.loc = $1.loc;
                    }
                ;

Expr            :   Expr1
                    {
                        $$.expr = $1.expr;
                    }
                |
                     '(' CLASS IDENTIFIER ')' Expr
                ;

Expr1           :   Expr2 ExprT1
                    {
                        $$.expr = $1.expr;
                        if ($2.expr != null) {
                            $$.expr = new Tree.Tertiary($$.expr, $2.expr, $2.expr1, $1.loc);
                        }
                    }
                ;

ExprT1          :   '?' Expr ':' Expr
                    {
                        $$.expr = $2.expr;
                        $$.expr1 = $4.expr;
                    }
                |   // empty
                    {

                    }
                ;

Expr2          :   Expr3 ExprT2
                    {
                        $$.expr = $1.expr;
                        if ($2.svec != null) {
                            for (int i = 0; i < $2.svec.size(); ++i) {
                                $$.expr = new Tree.Binary($2.svec.get(i), $$.expr, $2.evec.get(i), $2.lvec.get(i));
                            }
                        }
                    }
                ;

ExprT2         :   Oper2 Expr3 ExprT2
                    {
                        $$.svec = new Vector<Integer>();
                        $$.lvec = new Vector<Location>();
                        $$.evec = new Vector<Expr>();
                        $$.svec.add($1.signal);
                        $$.lvec.add($1.loc);
                        $$.evec.add($2.expr);
                        if ($3.svec != null) {
                            $$.svec.addAll($3.svec);
                            $$.lvec.addAll($3.lvec);
                            $$.evec.addAll($3.evec);
                        }
                    }
                |   // empty
                    {

                    }
                ;
Expr3          :   Expr4 ExprT3
                    {
                        $$.expr = $1.expr;
                        if ($2.svec != null) {
                            for (int i = 0; i < $2.svec.size(); ++i) {
                                $$.expr = new Tree.Binary($2.svec.get(i), $$.expr, $2.evec.get(i), $2.lvec.get(i));
                            }
                        }
                    }
                ;

ExprT3         :   Oper3 Expr4 ExprT3
                    {
                        $$.svec = new Vector<Integer>();
                        $$.lvec = new Vector<Location>();
                        $$.evec = new Vector<Expr>();
                        $$.svec.add($1.signal);
                        $$.lvec.add($1.loc);
                        $$.evec.add($2.expr);
                        if ($3.svec != null) {
                            $$.svec.addAll($3.svec);
                            $$.lvec.addAll($3.lvec);
                            $$.evec.addAll($3.evec);
                        }
                    }
                |   // empty
                    {

                    }
                ;
Expr4          :   Expr5 ExprT4
                    {
                        $$.expr = $1.expr;
                        if ($2.svec != null) {
                            for (int i = 0; i < $2.svec.size(); ++i) {
                                $$.expr = new Tree.Binary($2.svec.get(i), $$.expr, $2.evec.get(i), $2.lvec.get(i));
                            }
                        }
                    }
                ;

ExprT4         :   Oper4 Expr5 ExprT4
                    {
                        $$.svec = new Vector<Integer>();
                        $$.lvec = new Vector<Location>();
                        $$.evec = new Vector<Expr>();
                        $$.svec.add($1.signal);
                        $$.lvec.add($1.loc);
                        $$.evec.add($2.expr);
                        if ($3.svec != null) {
                            $$.svec.addAll($3.svec);
                            $$.lvec.addAll($3.lvec);
                            $$.evec.addAll($3.evec);
                        }
                    }
                |   // empty
                    {

                    }
                ;
Expr5          :   Expr6 ExprT5
                    {
                        $$.expr = $1.expr;
                        if ($2.svec != null) {
                            for (int i = 0; i < $2.svec.size(); ++i) {
                                $$.expr = new Tree.Binary($2.svec.get(i), $$.expr, $2.evec.get(i), $2.lvec.get(i));
                            }
                        }
                    }
                ;

ExprT5         :   Oper5 Expr6 ExprT5
                    {
                        $$.svec = new Vector<Integer>();
                        $$.lvec = new Vector<Location>();
                        $$.evec = new Vector<Expr>();
                        $$.svec.add($1.signal);
                        $$.lvec.add($1.loc);
                        $$.evec.add($2.expr);
                        if ($3.svec != null) {
                            $$.svec.addAll($3.svec);
                            $$.lvec.addAll($3.lvec);
                            $$.evec.addAll($3.evec);
                        }
                    }
                |   // empty
                    {

                    }
                ;
Expr6          :   Expr7 ExprT6
                    {
                        $$.expr = $1.expr;
                        if ($2.svec != null) {
                            for (int i = 0; i < $2.svec.size(); ++i) {
                                $$.expr = new Tree.Binary($2.svec.get(i), $$.expr, $2.evec.get(i), $2.lvec.get(i));
                            }
                        }
                    }
                ;

ExprT6         :   Oper6 Expr7 ExprT6
                    {
                        $$.svec = new Vector<Integer>();
                        $$.lvec = new Vector<Location>();
                        $$.evec = new Vector<Expr>();
                        $$.svec.add($1.signal);
                        $$.lvec.add($1.loc);
                        $$.evec.add($2.expr);
                        if ($3.svec != null) {
                            $$.svec.addAll($3.svec);
                            $$.lvec.addAll($3.lvec);
                            $$.evec.addAll($3.evec);
                        }
                    }
                |   // empty
                    {

                    }
                ;
Expr7          :   Expr8 ExprT7
                    {
                        $$.expr = $1.expr;
                        if ($2.svec != null) {
                            for (int i = 0; i < $2.svec.size(); ++i) {
                                $$.expr = new Tree.Binary($2.svec.get(i), $$.expr, $2.evec.get(i), $2.lvec.get(i));
                            }
                        }
                    }
                ;

ExprT7         :   Oper7 Expr8 ExprT7
                    {
                        $$.svec = new Vector<Integer>();
                        $$.lvec = new Vector<Location>();
                        $$.evec = new Vector<Expr>();
                        $$.svec.add($1.signal);
                        $$.lvec.add($1.loc);
                        $$.evec.add($2.expr);
                        if ($3.svec != null) {
                            $$.svec.addAll($3.svec);
                            $$.lvec.addAll($3.lvec);
                            $$.evec.addAll($3.evec);
                        }
                    }
                |   // empty
                    {

                    }
                ;

Expr8          :   Oper8 Expr8
                    {
                        $$.expr = new Tree.Unary($1.signal, $2.expr, $1.loc);
                    }
                |   Expr9
                    {
                        $$.expr = $1.expr;
                    }
                ;
Expr9          :   Oper9 Expr9
                    {
                        $$.expr = new Tree.Unary($1.signal, $2.expr, $1.loc);
                    }
                |   Expr10
                    {
                        $$.expr = $1.expr;
                    }
                ;

Expr10          :   Expr11 ExprT10
                    {
                        $$.expr = $1.expr;
                        if ($2.svec != null) {
                            for (int i = 0; i < $2.svec.size(); ++i) {
                                $$.expr = new Tree.Unary($2.svec.get(i), $$.expr, $2.lvec.get(i));
                            }
                        }
                    }
                ;

ExprT10         :   Oper10 ExprT10
                    {
                        $$.svec = new Vector<Integer>();
                        $$.lvec = new Vector<Location>();
                        $$.svec.add($1.signal);
                        $$.lvec.add($1.loc);
                        if ($2.svec != null) {
                            $$.svec.addAll($2.svec);
                            $$.lvec.addAll($2.lvec);
                        }
                    }
                |   // empty
                    {

                    }
                ;

Expr11          :   Expr12 ExprT11
                    {
                        $$.expr = $1.expr;
                        $$.loc = $1.loc;
                        if ($2.vec != null) {
                            for (SemValue v : $2.vec) {
                                if (v.expr != null) {
                                    $$.expr = new Tree.Indexed($$.expr, v.expr, $$.loc);
                                } else if (v.elist != null) {
                                    $$.expr = new Tree.CallExpr($$.expr, v.ident, v.elist, v.loc);
                                    $$.loc = v.loc;
                                } else {
                                    $$.expr = new Tree.Ident($$.expr, v.ident, v.loc);
                                    $$.loc = v.loc;
                                }
                            }
                        }
                    }
                ;

ExprT11         :   '[' Expr ']' ExprT11
                    {
                        SemValue sem = new SemValue();
                        sem.expr = $2.expr;
                        $$.vec = new Vector<SemValue>();
                        $$.vec.add(sem);
                        if ($4.vec != null) {
                            $$.vec.addAll($4.vec);
                        }
                    }
                |   '.' IDENTIFIER ExprAfterIdent ExprT11
                    {
                        SemValue sem = new SemValue();
                        sem.ident = $2.ident;
                        sem.loc = $2.loc;
                        sem.elist = $3.elist;
                        $$.vec = new Vector<SemValue>();
                        $$.vec.add(sem);
                        if ($4.vec != null) {
                            $$.vec.addAll($4.vec);
                        }
                    }
                |   // empty
                    {

                    }
                ;

Expr12          :   Constant
                    {
                        $$.expr = $1.expr;
                    }
                |   READ_INTEGER '(' ')'
                    {
                        $$.expr = new Tree.ReadIntExpr($1.loc);
                    }
                |   READ_LINE '(' ')'
                    {
                        $$.expr = new Tree.ReadLineExpr($1.loc);
                    }
                |   THIS
                    {
                        $$.expr = new Tree.ThisExpr($1.loc);
                    }
                |   NEW ExprAfterNew
                    {
                        if ($2.ident != null) {
                            $$.expr = new Tree.NewClass($2.ident, $1.loc);
                        } else {
                            $$.expr = new Tree.NewArray($2.type, $2.expr, $1.loc);
                        }
                    }
                |   INSTANCEOF '(' Expr ',' IDENTIFIER ')'
                    {
                        $$.expr = new Tree.TypeTest($3.expr, $5.ident, $1.loc);
                    }
                |   IDENTIFIER ExprAfterIdent
                    {
                        if ($2.elist != null) {
                            $$.expr = new Tree.CallExpr(null, $1.ident, $2.elist, $1.loc);
                        } else {
                            $$.expr = new Tree.Ident(null, $1.ident, $1.loc);
                        }
                    }
                |   '(' Expr ')'
                                        {
                                            $$.expr = $2.expr;
                                        }
                ;

ExprAfterNew    :   IDENTIFIER '(' ')'
                    {
                        $$.ident = $1.ident;
                    }
                |   SimpleType '[' ExprAfterST
                    {
                        $$.type = $1.type;
                        for (int i = 0; i < $3.signal; ++i) {
                            $$.type = new Tree.TypeArray($$.type, $1.loc);
                        }
                        $$.expr = $3.expr;
                    }
                ;

ExprAfterST     :   ']' '[' ExprAfterST
                    {
                        $$.expr = $3.expr;
                        $$.signal = 1 + $3.signal;
                    }
                |   Expr ']'
                    {
                        $$.expr = $1.expr;
                        $$.signal = 0;
                    }
                ;


ExprAfterIdent  :   '(' Actuals ')'
                    {
                        $$.elist = $2.elist;
                    }
                |   // empty
                    {

                    }
                ;

// Something wrong with literal!
Constant        :	LITERAL
					{
						$$.expr = new Tree.Literal($1.typeTag, $1.literal, $1.loc);
					}
                |	NULL
                	{
						$$.expr = new Null($1.loc);
					}
                ;

Actuals         :	ExprList
                    {
                        $$.elist = $1.elist;
                    }
                |	// empty
                	{
                		$$.elist = new ArrayList<Tree.Expr>();
                	}
                ;

ExprList        :   Expr SubExprList
                    {
                        $$.elist = new ArrayList<Tree.Expr>();
                        $$.elist.add($1.expr);
                        $$.elist.addAll($2.elist);
                    }
                ;

SubExprList     :   ',' Expr SubExprList
                    {
                        $$.elist = new ArrayList<Tree.Expr>();
                        $$.elist.add($2.expr);
                        $$.elist.addAll($3.elist);
                    }
                |   // empty
                    {
                        $$.elist = new ArrayList<Tree.Expr>();
                    }
                ;

SimpleType      :   INT
                    {
                        $$.type = new Tree.TypeIdent(Tree.INT, $1.loc);
                    }
                |   VOID
                    {
                        $$.type = new Tree.TypeIdent(Tree.VOID, $1.loc);
                    }
                |   BOOL
                    {
                        $$.type = new Tree.TypeIdent(Tree.BOOL, $1.loc);
                    }
                |   STRING
                    {
                        $$.type = new Tree.TypeIdent(Tree.STRING, $1.loc);
                    }
                |   CLASS IDENTIFIER
                    {
                        $$.type = new Tree.TypeClass($2.ident, $1.loc);
                    }
                ;
